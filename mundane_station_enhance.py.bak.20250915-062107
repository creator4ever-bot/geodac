# -*- coding: utf-8 -*-
import os, sys, json, re
from datetime import timedelta
from dateutil import parser as duparser, tz

PLANETS = r'(Солнце|Меркурий|Венера|Марс|Юпитер|Сатурн|Уран|Нептун|Плутон)'

def parse_dt_local_to_utc(s: str, default_tz='Europe/Moscow'):
    if not s: return None
    try:
        dt = duparser.parse(s)
        if dt.tzinfo:
            return dt.astimezone(tz.UTC)
        # naive: считаем локальным по TZ окружения
        loc = tz.gettz(os.environ.get('TZ', default_tz)) or tz.gettz(default_tz)
        dt = dt.replace(tzinfo=loc)
        return dt.astimezone(tz.UTC)
    except Exception:
        return None

def fmt_dt_utc(d):
    if d is None: return None
    return d.astimezone(tz.UTC).isoformat().replace('+00:00','Z')

def event_time_utc(ev):
    return parse_dt_local_to_utc(ev.get('peak') or ev.get('start') or ev.get('end') or '')

def detect_station(summary: str):
    s = summary or ''
    if re.search(r'разворот\s+назад', s, re.I):  return 'S->℞'
    if re.search(r'разворот\s+впер[её]д', s, re.I): return '℞->D'
    m = re.search(r'переход\s+в\s+(℞|R|RX|D)', s, re.I)
    if m:
        mode = m.group(1).upper()
        return 'S->℞' if mode in ('℞','R','RX') else '℞->D'
    m = re.search(r'станц\w*\s*(℞|R|RX|D)', s, re.I)
    if m:
        mode = m.group(1).upper()
        return '℞->D' if mode == 'D' else 'S->℞'
    m = re.search(r'\bS\s*[→\-]?\s*(℞|R|RX|D)\b', s, re.I)
    if m:
        mode = m.group(1).upper()
        return 'S->℞' if mode in ('℞','R','RX') else '℞->D'
    return None

def planet_from_summary(summary: str):
    m = re.match(rf'^{PLANETS}', summary or '')
    return m.group(1) if m else None

def sort_key(e):
    t = event_time_utc(e)
    tkey = t.isoformat(sep=' ') if t else ''
    summ = (e.get('summary') or '').lower()
    typ  = (e.get('type') or '').upper()
    prio = 0 if (typ in ('STATIONARY','STATION') or 'станц' in summ or 'разворот' in summ) else 1
    return (tkey, prio)

SB_RE  = re.compile(r'разворот\s+назад', re.I)
SF_RE  = re.compile(r'разворот\s+впер[её]д', re.I)
RX_RE  = re.compile(r'\bретроград', re.I)
DIR_RE = re.compile(r'\bдиректн', re.I)

def stitch_and_cleanup(ev_list):
    """
    - Стыкуем: SB (разворот назад) заканчивается ровно в старт RX (ретроградный).
    - Убираем: отдельные события «директный» (если вдруг появятся).
    """
    # 0) Уберём «директный» (мы используем SF как единственное событие для выхода из ретро)
    ev = []
    dropped_dir = 0
    for e in ev_list:
        s = e.get('summary') or ''
        if DIR_RE.search(s):
            dropped_dir += 1
            continue
        ev.append(e)

    # 1) Индекс RX по планете
    from collections import defaultdict
    rx_by_pl = defaultdict(list)  # pl -> [(idx, e, r0_utc)]
    for idx, e in enumerate(ev):
        s = e.get('summary') or ''
        if RX_RE.search(s):
            r0 = parse_dt_local_to_utc(e.get('start') or e.get('when') or e.get('peak') or '')
            pl = planet_from_summary(s)
            if pl and r0: rx_by_pl[pl].append((idx, e, r0))
    for pl in rx_by_pl:
        rx_by_pl[pl].sort(key=lambda t: t[2])

    # 2) Подрежем SB по старту ближайшего RX той же планеты
    stitched = 0
    for idx, e in enumerate(ev):
        s = e.get('summary') or ''
        if SB_RE.search(s):
            pl = planet_from_summary(s)
            if not pl: continue
            sb_start = parse_dt_local_to_utc(e.get('start') or '')
            sb_end   = parse_dt_local_to_utc(e.get('end')   or '')
            # момент станции — конец окна если есть, иначе старт
            tS = sb_end or sb_start
            cands = rx_by_pl.get(pl, [])
            if not tS or not cands: continue
            # ближайший RX к моменту станции
            j, e_rx, r0 = min(cands, key=lambda t: abs((t[2] - tS).total_seconds()))
            # Если RX раньше текущего конца SB — подрежем до r0 (стык)
            if sb_end and r0 and r0 != sb_end:
                # не допустим инверсию окна
                if sb_start and r0 < sb_start:
                    # если вдруг r0 раньше начала, не трогаем (защита)
                    continue
                e['end'] = fmt_dt_utc(r0)
                stitched += 1

    # 3) Финальная сортировка
    ev.sort(key=sort_key)
    return ev, stitched, dropped_dir

def main(path, dedup_hours=12):
    p = os.path.expanduser(path)
    data = json.load(open(p, encoding='utf-8'))
    ev = data.get('events', []) if isinstance(data, dict) else data

    # 1) Переименуем явные станции в «разворот …»
    for e in ev:
        s = e.get('summary') or ''
        k = detect_station(s)
        pl = planet_from_summary(s)
        if k and pl and ('разворот' not in s):
            e['summary'] = f"{pl} — разворот {'назад' if k=='S->℞' else 'вперёд'}"
            if not e.get('type'):
                e['type'] = 'STATIONARY'

    # 2) Сортировка
    ev.sort(key=sort_key)

    # 3) Dedup станций одной планеты/направления в пределах окна (12ч по умолчанию)
    TH = timedelta(hours=float(dedup_hours))
    keep = [True] * len(ev)
    st = []
    for i, e in enumerate(ev):
        s = e.get('summary') or ''
        if 'разворот' in s.lower():
            pl = planet_from_summary(s)
            direc = 'S->℞' if 'назад' in s.lower() else '℞->D'
            t = event_time_utc(e)
            if pl and t: st.append((i, pl, direc, t))
    st.sort(key=lambda x: (x[1], x[2], x[3]))

    last = {}  # (pl,dir) -> (idx, dt)
    for i, pl, dir, dt in st:
        key = (pl, dir)
        if key not in last:
            last[key] = (i, dt); continue
        j, dj = last[key]
        if abs((dt - dj)) <= TH:
            ei, ej = ev[i], ev[j]
            i_has_win = bool(ei.get('start') and ei.get('end'))
            j_has_win = bool(ej.get('start') and ej.get('end'))
            # снимаем менее «полезный»: без окна; если равны — более поздний
            drop = None
            if i_has_win and not j_has_win:
                drop = j; last[key] = (i, dt)
            elif j_has_win and not i_has_win:
                drop = i
            else:
                drop = i if dt >= dj else j
                if drop == j: last[key] = (i, dt)
            keep[drop] = False
        else:
            last[key] = (i, dt)

    ev2 = [e for k, e in zip(keep, ev) if k]

    # 4) Стыковка SB->RX и очистка DIR
    ev3, stitched, dropped_dir = stitch_and_cleanup(ev2)

    # 5) Запись
    out = {"events": ev3} if isinstance(data, dict) else ev3
    json.dump(out, open(p, 'w', encoding='utf-8'), ensure_ascii=False, indent=2)
    print(f"OK station enhance: dedup kept={len(ev3)} (removed {len(ev)-len(ev3)}), stitched={stitched}, dropped_dir={dropped_dir}, sorted")

if __name__=='__main__':
    if len(sys.argv) < 2:
        print("Usage: python mundane_station_enhance.py fixed.json [dedup_hours]"); sys.exit(1)
    dedup = float(sys.argv[2]) if len(sys.argv) >= 3 else 12.0
    main(sys.argv[1], dedup_hours=dedup)
