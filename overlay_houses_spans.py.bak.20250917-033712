# -*- coding: utf-8 -*-
import os, sys, json
from datetime import datetime, timedelta, timezone
import swisseph as swe

EPHE = os.path.expanduser('/home/DAC/Zet9 GeoDAC/Swiss')

PLANETS = [

    ('Mercury','☿', swe.MERCURY),
    ('Venus',  '♀', swe.VENUS),
    ('Mars',   '♂', swe.MARS),
    ('Jupiter','♃', swe.JUPITER),
    ('Saturn', '♄', swe.SATURN),
    ('Uranus', '♅', swe.URANUS),
    ('Neptune','♆', swe.NEPTUNE),
    ('Pluto',  '♇', swe.PLUTO),
]


SIGNS = ['♈','♉','♊','♋','♌','♍','♎','♏','♐','♑','♒','♓']
def sign_glyph_from_lon(lon):
    try:
        i = int((lon % 360)//30)
        return SIGNS[i]
    except Exception:
        return ''

HOUSE_THEMES = {
  1: 'личность, тело, имидж, старт циклов',
  2: 'деньги, ресурсы, опоры и стабильность',
  3: 'коммуникации, обучение, документы и поездки',
  4: 'дом, семья, основы, безопасность',
  5: 'творчество, сцена, радость, дети',
  6: 'служение, здоровье, режим и улучшения',
  7: 'отношения, контракты, зеркальные ситуации',
  8: 'общие финансы, доверие, интимность и глубина',
  9: 'смысл, дальние горизонты, вера, закон, обучение',
 10: 'карьера, статус, роль, направление роста',
 11: 'друзья, команды, сообщества, проекты',
 12: 'уединение, завершения, скрытые процессы, исцеление'
}

PLANET_ROLES = {
  'Mercury': ['переговоры/звонки', 'документы/переписка', 'поездки/логистика'],
  'Venus':   ['контакты/отношения', 'ресурсы/баланс', 'эстетика/комфорт'],
  'Mars':    ['энергия/действия', 'фокус/приоритезация', 'конфликт/отстаивание'],
  'Jupiter': ['рост/обучение', 'возможности/расширение', 'наставничество'],
  'Saturn':  ['структура/границы', 'ответственность/сроки', 'упрощение'],
  'Uranus':  ['перемены/новшества', 'свобода/автономия', 'ускорение'],
  'Neptune': ['интуиция/видение', 'туман/растворение', 'вдохновение'],
  'Pluto':   ['углубление/контроль', 'силовые темы', 'трансформация'],
}

def make_span_desc(name, glyph, h, lon):
    sign = sign_glyph_from_lon(lon)
    theme = HOUSE_THEMES.get(h, '')
    roles = PLANET_ROLES.get(name, [])
    # Подберём 2–3 индикатора по роли и теме дома
    ind = []
    if roles: ind.append(f"{roles[0]} в теме H{h} ({theme.split(',')[0]})")
    if len(roles)>1: ind.append(f"{roles[1]} заметны в быту H{h}")
    ind.append("смена ритма/внимания в сюжете дома")
    bullets = "\n".join(f"- {x}" for x in ind[:3])
    adv = "Отмечайте маркеры дома и самочувствие; короткие заметки помогут для ректификации."
    lines = [
        f"Темы дома H{h}: {theme}. Знак транзита: {sign}.",
        "Признаки:",
        bullets,
        f"Совет: {adv}",
    ]
    return "\n".join(lines).strip()

def make_ingress_desc(name, glyph, h_next, lon):
    sign = sign_glyph_from_lon(lon)
    theme = HOUSE_THEMES.get(h_next, '')
    roles = PLANET_ROLES.get(name, [])
    # Чек‑лист ингресса — что можно заметить
    ind = []
    if roles: ind.append(f"всплеск по: {roles[0]}")
    ind.append(f"включается тема H{h_next}: {theme.split(',')[0]}")
    ind.append("малые внешние/внутренние маркеры в течение суток")
    bullets = "\n".join(f"- {x}" for x in ind[:3])
    adv = "Зафиксируйте наблюдаемые маркеры и час; сопоставьте с расчётным временем для ректификации."
    lines = [
        f"Ингресс в H{h_next}. Знак транзита: {sign}.",
        "Признаки ингресса:",
        bullets,
        f"Совет: {adv}",
    ]
    return "\n".join(lines).strip()

def load_cusps(path):
    jp = os.path.expanduser(path)
    data = json.load(open(jp, encoding='utf-8'))
    cusps = data.get('cusps') or data.get('houses') or []
    if not isinstance(cusps, list):
        raise ValueError("cusps must be a list")
    # Фильтруем None/пустые строки и приводим к float
    cleaned = []
    for x in cusps:
        if x is None: 
            continue
        if isinstance(x, (int, float)):
            cleaned.append(float(x) % 360.0)
        elif isinstance(x, str):
            xs = x.strip()
            if not xs or xs.lower() == 'none':
                continue
            try:
                cleaned.append(float(xs) % 360.0)
            except Exception:
                pass
    # Если в файле был формат [None, cusp1..cusp12] — после фильтра получим 12 значений.
    if len(cleaned) > 12:
        cleaned = cleaned[-12:]
    if len(cleaned) != 12:
        raise ValueError(f"Need 12 cusps, got {len(cleaned)} from {jp}")
    return cleaned

def house_of(lon, cusps):
    # Возвращает дом 1..12 по списку куспидов (натальная сетка)
    lon = lon % 360.0
    c = cusps[:] + [cusps[0] + 360.0]
    for i in range(12):
        a, b = c[i] % 360.0, c[i+1] % 360.0
        if a <= b:
            if a <= lon < b: return i+1
        else:
            if lon >= a or lon < b: return i+1
    return 12

def planet_lon_ut(dt):
    jd = swe.julday(dt.year, dt.month, dt.day, dt.hour + dt.minute/60 + dt.second/3600.0)
    lon = swe.calc_ut(jd, cur_sid, swe.FLG_SWIEPH | swe.FLG_SPEED)[0][0]
    return lon % 360.0

def bracket_refine(cusps, t0, t1):
    # двоичный поиск момента смены дома в интервале
    h0 = house_of(planet_lon_ut(t0), cusps)
    for _ in range(24):  # ~до минут
        mid = t0 + (t1 - t0)/2
        hm = house_of(planet_lon_ut(mid), cusps)
        if hm == h0: t0 = mid
        else:        t1 = mid
    return t1

def spans_for_planet(name, glyph, sid, cusps, t_start, t_end, step_hours):
    global cur_sid
    cur_sid = sid
    spans=[]; ing=[]
    t = t_start
    cur_h = house_of(planet_lon_ut(t), cusps)
    span_start = t
    while t < t_end:
        t_next = min(t + timedelta(hours=step_hours), t_end)
        h_next = house_of(planet_lon_ut(t_next), cusps)
        if h_next != cur_h:
            ingress_time = bracket_refine(cusps, t, t_next)
            spans.append({
                'summary': f'{glyph} в H{cur_h}',
                'start': span_start.replace(tzinfo=timezone.utc).isoformat().replace('+00:00','Z'),
                'end':   ingress_time.replace(tzinfo=timezone.utc).isoformat().replace('+00:00','Z'),
                'description': 'Положение транзитной планеты в натальной сетке домов (overlay).',
                'category': 'OverlayHouses',
                'transparency': 'transparent',
                'busy': 'FREE'
            })
            ing.append({
                'summary': f'{glyph} → H{h_next} (ингресс)',
                'start': ingress_time.replace(tzinfo=timezone.utc).isoformat().replace('+00:00','Z'),
                'end':   (ingress_time + timedelta(minutes=30)).replace(tzinfo=timezone.utc).isoformat().replace('+00:00','Z'),
                'description': make_ingress_desc(name, glyph, h_next, planet_lon_ut(ingress_time)), 'category': 'OverlayHouses', 'extendedProperties': {'private': {'src':'geodac','overlay':'houses','planet': name,'ingress': 'true','to_house': str(h_next)}}
            })
            span_start = ingress_time
            cur_h = h_next
        t = t_next
    if span_start < t_end:
        spans.append({
            'summary': f'{glyph} в H{cur_h}',
            'start': span_start.replace(tzinfo=timezone.utc).isoformat().replace('+00:00','Z'),
            'end':   t_end.replace(tzinfo=timezone.utc).isoformat().replace('+00:00','Z'),
            'description': 'Положение транзитной планеты в натальной сетке домов (overlay).',
            'category': 'OverlayHouses',
            'transparency': 'transparent',
            'busy': 'FREE'
        })
    return spans, ing

def main():
    import argparse
    ap = argparse.ArgumentParser(description="Overlay Houses spans & ingresses")
    ap.add_argument('--cusps', default='~/astro/.state/natal_frame.json')
    ap.add_argument('--from', dest='date_from')
    ap.add_argument('--to',   dest='date_to')
    ap.add_argument('--step', type=float, default=6.0, help='шаг часов (для медленных планет достаточно 6ч)')
    args = ap.parse_args()

    cusps = load_cusps(args.cusps)
    swe.set_ephe_path(EPHE)

    now = datetime.utcnow().replace(tzinfo=timezone.utc)
    t_start = datetime.fromisoformat(args.date_from) if args.date_from else (now - timedelta(days=183))
    t_end   = datetime.fromisoformat(args.date_to)   if args.date_to   else (now + timedelta(days=183))
    if t_start.tzinfo is None: t_start = t_start.replace(tzinfo=timezone.utc)
    if t_end.tzinfo   is None: t_end   = t_end.replace(tzinfo=timezone.utc)

    all_spans=[]; all_ing=[]
    for name, glyph, sid in PLANETS:
        s, i = spans_for_planet(name, glyph, sid, cusps, t_start, t_end, args.step)
        all_spans += s; all_ing += i

    def dump(path, ev):
        ev = sorted(ev, key=lambda x: x.get('start') or '')
        json.dump({'events': ev}, open(os.path.expanduser(path),'w',encoding='utf-8'), ensure_ascii=False, indent=2)
        print(f"OK: {path} events={len(ev)}")

    dump('~/astro/overlay_spans.json',     all_spans)
    dump('~/astro/overlay_ingresses.json', all_ing)

if __name__ == '__main__':
    main()
